!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CACHE_VOL	dev-args.h	19;"	d
CBLOCK_SIZE	dev-args.h	21;"	d
CONCATENATE	pp_narg.h	79;"	d
DEV_ARGS	dev-args.h	2;"	d
DIRTY_BIT	xcache-dev.h	9;"	d
DOOR	xlg_assert.h	24;"	d
DOOR	xlg_assert.h	26;"	d
FOR_EACH	pp_narg.h	81;"	d
FOR_EACH_	pp_narg.h	80;"	d
FOR_EACH_0	pp_narg.h	35;"	d
FOR_EACH_1	pp_narg.h	36;"	d
FOR_EACH_10	pp_narg.h	61;"	d
FOR_EACH_11	pp_narg.h	64;"	d
FOR_EACH_12	pp_narg.h	67;"	d
FOR_EACH_13	pp_narg.h	70;"	d
FOR_EACH_14	pp_narg.h	73;"	d
FOR_EACH_15	pp_narg.h	76;"	d
FOR_EACH_2	pp_narg.h	37;"	d
FOR_EACH_3	pp_narg.h	40;"	d
FOR_EACH_4	pp_narg.h	43;"	d
FOR_EACH_5	pp_narg.h	46;"	d
FOR_EACH_6	pp_narg.h	49;"	d
FOR_EACH_7	pp_narg.h	52;"	d
FOR_EACH_8	pp_narg.h	55;"	d
FOR_EACH_9	pp_narg.h	58;"	d
GATE	xlg_assert.h	21;"	d
HARDSECT_SIZE	dev-args.h	23;"	d
KERNELDIR	Makefile	/^	KERNELDIR ?= \/lib\/modules\/$(shell uname -r)\/build$/;"	m
KERNEL_SECTOR_SIZE	xlg-dev.c	19;"	d	file:
LOCK_BIT	xcache-dev.h	11;"	d
MICRO_PP_NARG_H	pp_narg.h	2;"	d
NBLOCKS	dev-args.h	22;"	d
NSECTORS	dev-args.h	24;"	d
PHD_NAME	dev-args.h	25;"	d
PH_VOL	dev-args.h	20;"	d
PP_ARG_N	pp_narg.h	9;"	d
PP_NARG	pp_narg.h	7;"	d
PP_NARG_	pp_narg.h	8;"	d
PP_RSEQ_N	pp_narg.h	17;"	d
PP_SHORT_ARG_N	pp_narg.h	31;"	d
PP_SHORT_NARG	pp_narg.h	29;"	d
PP_SHORT_NARG_	pp_narg.h	30;"	d
PP_SHORT_RSEQ_N	pp_narg.h	33;"	d
PWD	Makefile	/^	PWD := $(shell pwd)$/;"	m
SDOOR	xlg_assert.h	17;"	d
SDOOR	xlg_assert.h	7;"	d
WRITING_BACK_BIT	xcache-dev.h	10;"	d
XCACHE_DEV	xcache-dev.h	2;"	d
XLG_ASSERT_H	xlg_assert.h	2;"	d
XLG_DEV	xlg-dev.h	2;"	d
XLG_MINORS	xlg-dev.c	18;"	d	file:
XPH_DEV	xph-dev.h	2;"	d
_SAFETY_DOOR_	xlg_assert.h	4;"	d
__this_module	module.mod.c	/^struct module __this_module$/;"	v	typeref:struct:module
__used	module.mod.c	/^__used$/;"	v	file:
__used	module.mod.c	/^__used$/;"	v	typeref:struct:____versions	file:
bdev	xlg-dev.h	/^	struct block_device	*bdev;			\/* Physical block device *\/$/;"	m	struct:xlg_dev	typeref:struct:xlg_dev::block_device
block_list	xcache-dev.h	/^	struct list_head 	block_list;		\/* block list; *\/$/;"	m	struct:cache_block	typeref:struct:cache_block::list_head
cache	xlg-dev.h	/^	struct xcache  		cache;			\/* The device cache *\/$/;"	m	struct:xlg_dev	typeref:struct:xlg_dev::xcache
cache_block	xcache-dev.h	/^struct cache_block {$/;"	s
cache_block_xfer	xcache-dev.c	/^static void cache_block_xfer(struct bio_vec *bv, struct cache_block$/;"	f	file:
cache_blocks	xcache-dev.h	/^	struct list_head 	cache_blocks;		\/* list linking the cached blocks; *\/$/;"	m	struct:cache_zone	typeref:struct:cache_zone::list_head
cache_blocks_add	xcache-dev.c	/^static void cache_blocks_add(struct cache_block *blk, struct cache_zone *cz)$/;"	f	file:
cache_need_flush	xcache-dev.c	/^static inline int cache_need_flush(struct xcache *cache)$/;"	f	file:
cache_zone	xcache-dev.h	/^	struct cache_zone 	cache_zone;		\/* the zone containing the cached blocks; *\/$/;"	m	struct:xcache	typeref:struct:xcache::cache_zone
cache_zone	xcache-dev.h	/^struct cache_zone {$/;"	s
dev	xlg-dev.c	/^struct xlg_dev *dev;					\/* the logical device *\/$/;"	v	typeref:struct:xlg_dev
find_cache_block	xcache-dev.c	/^static int find_cache_block(sector_t sector, struct cache_block **cb)$/;"	f	file:
flag	xcache-dev.h	/^	unsigned long		flag;			\/* the status flag of the block; *\/$/;"	m	struct:cache_block
flush_all_cache_blocks	xcache-dev.c	/^static void flush_all_cache_blocks(void)$/;"	f	file:
flush_cache_block	xcache-dev.c	/^static void flush_cache_block(struct cache_block *colbk)$/;"	f	file:
flush_cold_cache_block	xcache-dev.c	/^static void flush_cold_cache_block(struct work_struct *work)$/;"	f	file:
free_all_cache_blocks	xcache-dev.c	/^static void free_all_cache_blocks(struct list_head *free_blocks)$/;"	f	file:
free_blocks	xcache-dev.h	/^	struct list_head	free_blocks;		\/* list linking the free blocks; *\/$/;"	m	struct:free_zone	typeref:struct:free_zone::list_head
free_blocks_add	xcache-dev.c	/^static void free_blocks_add(struct cache_block *blk, struct free_zone *fz) $/;"	f	file:
free_zone	xcache-dev.h	/^	struct free_zone  	free_zone;		\/* the zone linking the free blocks; *\/$/;"	m	struct:xcache	typeref:struct:xcache::free_zone
free_zone	xcache-dev.h	/^struct free_zone {$/;"	s
gd	xlg-dev.h	/^	struct gendisk 		*gd;			\/* The gendisk structure *\/$/;"	m	struct:xlg_dev	typeref:struct:xlg_dev::gendisk
get_cache_block	xcache-dev.c	/^struct cache_block *get_cache_block(struct free_zone *fz)$/;"	f
get_coldest_cache_block	xcache-dev.c	/^static struct cache_block *get_coldest_cache_block(struct xcache *cache) {$/;"	f	file:
hardsect_size	xlg-dev.c	/^static int hardsect_size = HARDSECT_SIZE;		\/* device sector size *\/$/;"	v	file:
insert_block_to_radix_tree	xcache-dev.c	/^static inline int insert_block_to_radix_tree(struct cache_block *cb, struct radix_tree_root *rdtree, $/;"	f	file:
lock	xcache-dev.h	/^	spinlock_t		lock;			\/* spinlock for protecting list_head; *\/$/;"	m	struct:free_zone
lock	xcache-dev.h	/^	spinlock_t 		lock;			\/* spinlock for protecting list_head; *\/$/;"	m	struct:cache_zone
lock	xlg-dev.h	/^	spinlock_t 		lock;			\/* For mutual exclusion *\/$/;"	m	struct:xlg_dev
main	test.c	/^int main()$/;"	f
module-objs	Makefile	/^	module-objs := xlg-dev.o xcache-dev.o xph-dev.o$/;"	m
new_cache_block	xcache-dev.c	/^static struct cache_block *new_cache_block(void)$/;"	f	file:
nsectors	xlg-dev.c	/^static int nsectors = NSECTORS;				\/* sector num of the device *\/$/;"	v	file:
obj-m	Makefile	/^	obj-m :=module.o$/;"	m
page	xcache-dev.h	/^	struct page		*page;			\/* the page volumn of the block for storing; *\/$/;"	m	struct:cache_block	typeref:struct:cache_block::page
phd_name	xph-dev.c	/^const char *phd_name = PHD_NAME;$/;"	v
queue	xlg-dev.h	/^	struct request_queue 	*queue;			\/* The device request queue *\/$/;"	m	struct:xlg_dev	typeref:struct:xlg_dev::request_queue
rdtree	xcache-dev.h	/^	struct radix_tree_root 	rdtree;			\/* radix tree for managing the cached blocks; *\/$/;"	m	struct:cache_zone	typeref:struct:cache_zone::radix_tree_root
recycle_cache_block	xcache-dev.c	/^void recycle_cache_block(struct cache_block *colbk) $/;"	f
ref_cnt	xcache-dev.h	/^	atomic_t		ref_cnt;		\/* the reference count of the blcock; *\/$/;"	m	struct:cache_block
request_queue_t	xlg-dev.c	/^typedef struct request_queue request_queue_t; 		\/* 2.6.32 cancle it, so add it here; *\/$/;"	t	typeref:struct:request_queue	file:
sector	xcache-dev.h	/^	unsigned long 		sector;			\/* The starting sector number of the block; *\/$/;"	m	struct:cache_block
setup_device	xlg-dev.c	/^int setup_device(void)$/;"	f
size	xcache-dev.h	/^	atomic_t		size;			\/* the num of free blocks; *\/$/;"	m	struct:free_zone
size	xlg-dev.h	/^	int 			size;			\/* Device size in sectors *\/$/;"	m	struct:xlg_dev
users	xlg-dev.h	/^	short 			users;			\/* How many users *\/$/;"	m	struct:xlg_dev
wait_schedule	xcache-dev.c	/^static int wait_schedule(void *data)$/;"	f	file:
waitq	xcache-dev.h	/^	wait_queue_head_t	waitq;			\/* waitqueue for thread waiting for someting; *\/$/;"	m	struct:cache_block
waitq	xcache-dev.h	/^	wait_queue_head_t  	waitq;			\/* waitqueue for thread waiting; *\/$/;"	m	struct:xcache
work	xcache-dev.h	/^	struct work_struct 	work;			\/* the work being linked to the default workqueue; *\/$/;"	m	struct:xcache	typeref:struct:xcache::work_struct
write_xph_endio	xph-dev.c	/^void write_xph_endio(struct bio *bio, int err)$/;"	f
xcache	xcache-dev.h	/^struct xcache {$/;"	s
xcache_destroy	xcache-dev.c	/^int xcache_destroy()$/;"	f
xcache_init	xcache-dev.c	/^int xcache_init()$/;"	f
xcache_xfer	xcache-dev.c	/^int xcache_xfer(struct bio_vec *bv, sector_t sector, unsigned long dir)$/;"	f
xd_name	xlg-dev.c	/^static const char *xd_name = "xlg_dev";			\/* device name *\/$/;"	v	file:
xlg_dev	xlg-dev.h	/^struct xlg_dev {$/;"	s
xlg_exit	xlg-dev.c	/^module_exit(xlg_exit);$/;"	v
xlg_exit	xlg-dev.c	/^static void __exit xlg_exit(void)$/;"	f	file:
xlg_first_minor	xlg-dev.c	/^static int xlg_first_minor = 0;				\/* first minor device number *\/$/;"	v	file:
xlg_init	xlg-dev.c	/^module_init(xlg_init);$/;"	v
xlg_init	xlg-dev.c	/^static int __init xlg_init(void)$/;"	f	file:
xlg_ioctl	xlg-dev.c	/^static int xlg_ioctl(struct inode *inode, struct file *filp,$/;"	f	file:
xlg_major	xlg-dev.c	/^static int xlg_major = 0;				\/* major device number, 0 means getting a new number *\/$/;"	v	file:
xlg_make_request	xlg-dev.c	/^static int xlg_make_request(request_queue_t *q, struct bio *bio)$/;"	f	file:
xlg_open	xlg-dev.c	/^static int xlg_open(struct inode *inode, struct file *filp)$/;"	f	file:
xlg_ops	xlg-dev.c	/^static struct block_device_operations xlg_ops = {$/;"	v	typeref:struct:block_device_operations	file:
xlg_release	xlg-dev.c	/^static int xlg_release(struct inode *inode, struct file *filp)$/;"	f	file:
xph_bio_read_block	xph-dev.h	9;"	d
xph_bio_write_block	xph-dev.h	8;"	d
xph_bio_xfer	xph-dev.c	/^int  xph_bio_xfer(int dir, struct cache_block *cb)$/;"	f
xph_construct_bio	xph-dev.c	/^static struct bio *xph_construct_bio(int dir, struct cache_block *cb)$/;"	f	file:
xph_destroy	xph-dev.c	/^void xph_destroy(void)$/;"	f
xph_init	xph-dev.c	/^struct block_device *xph_init(void)$/;"	f
